<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/6b40bd379144f5c8.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-07dfb49dd72788a4.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-e4950b334bc218cf.js" async="" crossorigin=""></script><script src="/_next/static/chunks/472-23f435a9c16afa13.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-efee19f0ce613ad9.js" async="" crossorigin=""></script><script src="/_next/static/chunks/326-c01c22be8dcac7b1.js" async=""></script><script src="/_next/static/chunks/app/docs/%5B...slug%5D/page-f5028c860b0f5f1d.js" async=""></script><title>Engineering 101</title><meta name="description" content="SOLID + DDD training site"/><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="antialiased"><div class="flex min-h-screen bg-gray-50"><aside class="sidebar"><div class="sidebar-nav"><a class="text-lg font-semibold text-gray-900 mb-4 block hover:text-blue-600" href="/">‚Üê Engineering 101</a><h2 class="text-lg font-semibold text-gray-900 mb-4">Course Content</h2><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles">1-SOLID-Principles</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/0-README">0-README</a></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/1-Single-class-reponsibility-principle">1-Single-class-reponsibility-principle</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/1-Single-class-reponsibility-principle/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/2-Open-closed-principle">2-Open-closed-principle</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/2-Open-closed-principle/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/3-Liskov-substitution-principle">3-Liskov-substitution-principle</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/3-Liskov-substitution-principle/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/4-Interface-segregation-principle">4-Interface-segregation-principle</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/4-Interface-segregation-principle/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/5-Dependency-segregation-principle">5-Dependency-segregation-principle</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/5-Dependency-segregation-principle/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application">reference-application</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/CI-README">CI-README</a></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Dotnet">Dotnet</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Dotnet/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Java">Java</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Java/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Python">Python</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Python/.pytest_cache">.pytest_cache</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Python/.pytest_cache/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/Python/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/README">README</a></li><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/TypeScript">TypeScript</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/1-SOLID-Principles/reference-application/TypeScript/README">README</a></li></ul></div></li></ul></div></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design">2-Domain-Driven-Design</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/0-README">0-README</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/1-Bounded-Contexts">1-Bounded-Contexts</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/1-Bounded-Contexts/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/1-introduction-to-the-domain">1-introduction-to-the-domain</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/2-Ubiquitous-Language">2-Ubiquitous-Language</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/2-Ubiquitous-Language/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/3-Domain-Models">3-Domain-Models</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/3-Domain-Models/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/4-Context-Mapping">4-Context-Mapping</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/4-Context-Mapping/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/5-Strategic-Patterns">5-Strategic-Patterns</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/5-Strategic-Patterns/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples">code-samples</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/README">README</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp">csharp</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/02-order-entity">02-order-entity</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/03-money-value-object">03-money-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/04-email-address-value-object">04-email-address-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/05-pricing-service">05-pricing-service</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/06-customer-module">06-customer-module</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/07-order-tests">07-order-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/08-money-tests">08-money-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/09-pricing-service-tests">09-pricing-service-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/11-testing-anti-patterns">11-testing-anti-patterns</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/12-testing-best-practices">12-testing-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/13-domain-modeling-best-practices">13-domain-modeling-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/csharp/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/introduction-to-the-domain">introduction-to-the-domain</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java">java</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/02-money-value-object">02-money-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/03-inventory-service">03-inventory-service</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/03-order-entity">03-order-entity</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/04-email-address-value-object">04-email-address-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/04-order-tests">04-order-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/05-pricing-service">05-pricing-service</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/06-customer-module">06-customer-module</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/07-order-tests">07-order-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/08-money-tests">08-money-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/09-pricing-service-tests">09-pricing-service-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/11-testing-anti-patterns">11-testing-anti-patterns</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/12-testing-best-practices">12-testing-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/13-domain-modeling-best-practices">13-domain-modeling-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/java/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python">python</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/02-money-value-object">02-money-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/03-order-entity">03-order-entity</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/04-email-address-value-object">04-email-address-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/05-pricing-service">05-pricing-service</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/06-customer-module">06-customer-module</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/07-order-tests">07-order-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/08-money-tests">08-money-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/09-pricing-service-tests">09-pricing-service-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/11-testing-anti-patterns">11-testing-anti-patterns</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/12-testing-best-practices">12-testing-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/13-domain-modeling-best-practices">13-domain-modeling-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/python/README">README</a></li></ul></div></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript">typescript</a><div class="ml-4 mt-1"><ul class="space-y-1"><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/02-money-value-object">02-money-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/03-order-entity">03-order-entity</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/04-email-address-value-object">04-email-address-value-object</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/05-pricing-service">05-pricing-service</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/06-customer-module">06-customer-module</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/07-order-tests">07-order-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/08-money-tests">08-money-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/09-pricing-service-tests">09-pricing-service-tests</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/11-testing-anti-patterns">11-testing-anti-patterns</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/12-testing-best-practices">12-testing-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/13-domain-modeling-best-practices">13-domain-modeling-best-practices</a></li><li><a class="sidebar-item" href="/docs/2-Domain-Driven-Design/code-samples/typescript/README">README</a></li></ul></div></li></ul></div></li></ul></div></li></ul></div></aside><main class="main-content"><div class="content-wrapper"><div class="page-header"><h1 class="page-title">README</h1></div><div class="prose prose-lg max-w-none"><div><h1>Liskov Substitution Principle (LSP)</h1>
<h2>Name</h2>
<p><strong>Liskov Substitution Principle</strong> - The &quot;L&quot; in SOLID</p>
<h2>Goal of the Principle</h2>
<p>Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. Derived classes must be substitutable for their base classes, maintaining the same behavior and contracts.</p>
<h2>Theoretical Foundation</h2>
<h3>Barbara Liskov&#39;s Original Work</h3>
<p>The Liskov Substitution Principle was formally defined by Barbara Liskov in 1987 as part of her work on abstract data types and behavioral subtyping. Liskov&#39;s work established the mathematical foundation for understanding when one type can safely substitute for another.</p>
<h3>Behavioral Subtyping Theory</h3>
<p>LSP formalizes the concept of behavioral subtyping, which states that a subtype should be substitutable for its supertype in all contexts. This is more restrictive than structural subtyping, which only requires matching method signatures.</p>
<h3>Design by Contract</h3>
<p>The principle is closely related to Bertrand Meyer&#39;s Design by Contract methodology:</p>
<ul>
<li><strong>Preconditions</strong>: Conditions that must be true before a method is called</li>
<li><strong>Postconditions</strong>: Conditions that must be true after a method completes</li>
<li><strong>Invariants</strong>: Conditions that must always be true for an object</li>
</ul>
<h3>Type Theory and Polymorphism</h3>
<p>LSP ensures that polymorphism works correctly by guaranteeing that:</p>
<ul>
<li>Method calls on derived objects produce expected results</li>
<li>Derived objects maintain the same invariants as base objects</li>
<li>Exception handling remains consistent across the inheritance hierarchy</li>
</ul>
<h3>Mathematical Foundation</h3>
<p>The principle is based on the mathematical concept of substitutability, where if S is a subtype of T, then objects of type S can replace objects of type T without changing the correctness of the program.</p>
<h2>Consequences of Violating LSP</h2>
<h3>Unique LSP-Specific Issues</h3>
<p><strong>Polymorphism Breakdown</strong></p>
<ul>
<li>Code using base class references may fail with derived class objects</li>
<li>Generic algorithms may produce incorrect results</li>
<li>Collection operations may behave unexpectedly</li>
<li>Framework code may malfunction</li>
</ul>
<p><strong>Contract Violations</strong></p>
<ul>
<li>Methods may throw unexpected exceptions</li>
<li>Return values may not match expected types</li>
<li>Side effects may differ from base class behavior</li>
<li>Program correctness cannot be guaranteed</li>
</ul>
<p><strong>Testing Inconsistencies</strong></p>
<ul>
<li>Tests that pass with base classes may fail with derived classes</li>
<li>Mock objects may not behave like real objects</li>
<li>Integration tests become unreliable</li>
<li>Test coverage becomes meaningless</li>
</ul>
<p><strong>Inheritance Hierarchy Problems</strong></p>
<ul>
<li>Changes to derived classes can break existing code</li>
<li>Inheritance hierarchies become unreliable</li>
<li>Code reuse becomes dangerous</li>
<li>Refactoring becomes risky</li>
</ul>
<h2>Impact on Static Code Analysis</h2>
<h3>LSP-Specific Metrics</h3>
<p><strong>Polymorphism Reliability</strong></p>
<ul>
<li>Consistent behavior across inheritance hierarchies improves reliability scores</li>
<li>Predictable polymorphism reduces complexity in static analysis</li>
<li>Better inheritance design metrics in tools like SonarQube</li>
</ul>
<p><strong>Contract Compliance Detection</strong></p>
<ul>
<li>Tools can detect violations of method contracts</li>
<li>Identification of precondition/postcondition violations</li>
<li>Detection of invariant breaking in subclasses</li>
</ul>
<h3>LSP-Specific Tool Benefits</h3>
<p><strong>ESLint/TSLint (JavaScript/TypeScript)</strong></p>
<ul>
<li>Better &quot;no-dupe-class-members&quot; compliance</li>
<li>Improved &quot;no-useless-constructor&quot; usage</li>
<li>Reduced &quot;prefer-const&quot; violations in inheritance</li>
</ul>
<p><strong>Checkstyle (Java)</strong></p>
<ul>
<li>Better &quot;VisibilityModifier&quot; compliance</li>
<li>Improved &quot;MethodLength&quot; in inheritance hierarchies</li>
</ul>
<p><strong>FxCop/StyleCop (.NET)</strong></p>
<ul>
<li>Fewer &quot;CA1501&quot; (Avoid excessive inheritance) violations</li>
</ul>
<h3>LSP-Specific Detection</h3>
<p><strong>LSP Violation Detection</strong></p>
<ul>
<li>Detection of subclasses that don&#39;t honor base class contracts</li>
<li>Identification of methods that throw unexpected exceptions</li>
<li>Recognition of return type violations in inheritance</li>
<li>Detection of invariant breaking in subclasses</li>
</ul>
<p><strong>Inheritance Analysis</strong></p>
<ul>
<li>Analysis of inheritance hierarchy depth and breadth</li>
<li>Detection of proper abstract class usage</li>
<li>Recognition of interface implementation compliance</li>
</ul>
<h2>Role in Improving Software Quality</h2>
<p>The Liskov Substitution Principle is essential for maintaining the integrity of object-oriented design. It ensures that:</p>
<ul>
<li><strong>Reliability</strong>: Subclasses behave predictably when substituted for base classes</li>
<li><strong>Consistency</strong>: Inheritance relationships maintain their intended behavior</li>
<li><strong>Maintainability</strong>: Changes to subclasses don&#39;t break existing code</li>
<li><strong>Testability</strong>: Subclasses can be tested using the same test cases as base classes</li>
<li><strong>Polymorphism</strong>: Runtime polymorphism works correctly and safely</li>
</ul>
<h2>How to Apply This Principle</h2>
<h3>1. Maintain Contracts</h3>
<p><strong>What it means</strong>: Subclasses must honor the contracts established by their base classes. This includes method signatures, return types, exception handling, and behavioral expectations.</p>
<p><strong>How to do it</strong>:</p>
<ul>
<li>Ensure subclasses implement all methods from the base class with compatible signatures</li>
<li>Maintain the same return types or use covariant return types where appropriate</li>
<li>Don&#39;t change method parameters in ways that would break existing callers</li>
<li>Preserve the semantic meaning of method names and their intended behavior</li>
</ul>
<p><strong>Example from our code samples</strong>: In the violating <code>Bird</code> example, the <code>Penguin</code> class throws an exception when <code>Fly()</code> is called, breaking the contract that all birds can fly. The refactored solution creates separate interfaces (<code>IFlyingBird</code> and <code>ISwimmingBird</code>) so that each subclass only implements contracts it can actually honor.</p>
<h3>2. Preserve Invariants</h3>
<p><strong>What it means</strong>: Subclasses must maintain the same invariants (conditions that are always true) as their base classes. These are the fundamental properties that define the object&#39;s state and behavior.</p>
<p><strong>How to do it</strong>:</p>
<ul>
<li>Identify the invariants that the base class maintains</li>
<li>Ensure subclasses don&#39;t violate these invariants in their implementations</li>
<li>Document invariants clearly so subclasses understand what they must preserve</li>
<li>Test invariants to ensure they hold for all subclasses</li>
</ul>
<p><strong>Example from our code samples</strong>: In the violating <code>Rectangle</code>/<code>Square</code> example, the <code>Square</code> class changes the behavior of <code>setWidth()</code> and <code>setHeight()</code> methods, violating the invariant that these methods should only affect their respective dimensions. The refactored solution makes <code>Square</code> a separate class with its own <code>setSide()</code> method, preserving the invariants of both shapes.</p>
<h3>3. Avoid Weakening Preconditions</h3>
<p><strong>What it means</strong>: Subclasses should not impose stricter requirements on their methods than the base class does. This would make the subclass less substitutable, not more.</p>
<p><strong>How to do it</strong>:</p>
<ul>
<li>Don&#39;t add additional validation or requirements in subclass methods</li>
<li>Don&#39;t require additional parameters or more specific types</li>
<li>Don&#39;t impose stricter business rules than the base class</li>
<li>If you need stricter validation, consider composition instead of inheritance</li>
</ul>
<p><strong>Example from our code samples</strong>: If a base class <code>PaymentProcessor</code> accepts any amount greater than zero, a subclass shouldn&#39;t require amounts to be above $10. This would make the subclass unusable in contexts where the base class is expected to handle smaller amounts.</p>
<h3>4. Avoid Strengthening Postconditions</h3>
<p><strong>What it means</strong>: Subclasses should not weaken the guarantees made by base class methods. This would break the expectations of code that depends on the base class behavior.</p>
<p><strong>How to do it</strong>:</p>
<ul>
<li>Don&#39;t reduce the functionality or capabilities promised by base class methods</li>
<li>Don&#39;t change return values in ways that would break existing code</li>
<li>Don&#39;t remove side effects that calling code might depend on</li>
<li>If you need different behavior, consider composition or a different inheritance hierarchy</li>
</ul>
<p><strong>Example from our code samples</strong>: If a base class <code>Logger</code> guarantees that all messages will be written to a file, a subclass shouldn&#39;t only log messages above a certain priority level. This would break the contract and make the subclass unsuitable for contexts requiring all messages to be logged.</p>
<h3>5. Use Composition Over Inheritance</h3>
<p><strong>What it means</strong>: When substitution becomes problematic or creates awkward inheritance relationships, consider using composition instead. This often leads to more flexible and maintainable designs.</p>
<p><strong>How to do it</strong>:</p>
<ul>
<li>Identify when inheritance relationships don&#39;t naturally fit the &quot;is-a&quot; relationship</li>
<li>Use composition to combine behaviors from multiple sources</li>
<li>Create interfaces that define the capabilities you need</li>
<li>Implement these interfaces through composition rather than inheritance</li>
</ul>
<p><strong>Example from our code samples</strong>: The refactored <code>Bird</code> solution uses composition by creating separate interfaces for different capabilities (<code>IFlyingBird</code>, <code>ISwimmingBird</code>). A <code>Penguin</code> implements <code>ISwimmingBird</code> and can be used wherever swimming behavior is needed, without forcing it to implement flying behavior it doesn&#39;t have.</p>
<h2>Examples of Violations and Refactoring</h2>
<h3>C# Example</h3>
<p><strong>Violating LSP:</strong></p>
<pre><code class="language-csharp">public class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine(&quot;Flying...&quot;);
    }
    
    public virtual void Eat()
    {
        Console.WriteLine(&quot;Eating...&quot;);
    }
}

public class Eagle : Bird
{
    public override void Fly()
    {
        Console.WriteLine(&quot;Eagle soaring high...&quot;);
    }
}

public class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotImplementedException(&quot;Penguins can&#39;t fly!&quot;);
    }
}

// This violates LSP because Penguin can&#39;t substitute Bird
public class BirdWatcher
{
    public void WatchBird(Bird bird)
    {
        bird.Eat();
        bird.Fly(); // This will throw exception for Penguin!
    }
}
</code></pre>
<p><strong>Refactored - Applying LSP:</strong></p>
<pre><code class="language-csharp">// Base interface for all birds
public interface IBird
{
    void Eat();
}

// Interface for flying birds only
public interface IFlyingBird : IBird
{
    void Fly();
}

// Interface for swimming birds
public interface ISwimmingBird : IBird
{
    void Swim();
}

// Concrete implementations that honor their contracts
public class Eagle : IFlyingBird
{
    public void Eat()
    {
        Console.WriteLine(&quot;Eagle eating...&quot;);
    }
    
    public void Fly()
    {
        Console.WriteLine(&quot;Eagle soaring high...&quot;);
    }
}

public class Penguin : ISwimmingBird
{
    public void Eat()
    {
        Console.WriteLine(&quot;Penguin eating...&quot;);
    }
    
    public void Swim()
    {
        Console.WriteLine(&quot;Penguin swimming...&quot;);
    }
}

// Now substitution works correctly
public class BirdWatcher
{
    public void WatchFlyingBird(IFlyingBird bird)
    {
        bird.Eat();
        bird.Fly(); // Safe - all flying birds can fly
    }
    
    public void WatchSwimmingBird(ISwimmingBird bird)
    {
        bird.Eat();
        bird.Swim(); // Safe - all swimming birds can swim
    }
}
</code></pre>
<h3>Java Example</h3>
<p><strong>Violating LSP:</strong></p>
<pre><code class="language-java">public class Rectangle {
    protected int width;
    protected int height;
    
    public void setWidth(int width) {
        this.width = width;
    }
    
    public void setHeight(int height) {
        this.height = height;
    }
    
    public int getArea() {
        return width * height;
    }
}

public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width; // Violates LSP - changes behavior
    }
    
    @Override
    public void setHeight(int height) {
        this.width = height; // Violates LSP - changes behavior
        this.height = height;
    }
}

// This violates LSP because Square changes Rectangle&#39;s behavior
public class AreaCalculator {
    public void calculateArea(Rectangle rectangle) {
        rectangle.setWidth(5);
        rectangle.setHeight(4);
        // Expects 20, but gets 16 for Square!
        System.out.println(&quot;Area: &quot; + rectangle.getArea());
    }
}
</code></pre>
<p><strong>Refactored - Applying LSP:</strong></p>
<pre><code class="language-java">// Abstract base class that defines the contract
public abstract class Shape {
    public abstract int getArea();
}

// Concrete implementations that honor their contracts
public class Rectangle extends Shape {
    private int width;
    private int height;
    
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
    
    public void setWidth(int width) {
        this.width = width;
    }
    
    public void setHeight(int height) {
        this.height = height;
    }
    
    @Override
    public int getArea() {
        return width * height;
    }
}

public class Square extends Shape {
    private int side;
    
    public Square(int side) {
        this.side = side;
    }
    
    public void setSide(int side) {
        this.side = side;
    }
    
    @Override
    public int getArea() {
        return side * side;
    }
}

// Now substitution works correctly
public class AreaCalculator {
    public void calculateArea(Shape shape) {
        System.out.println(&quot;Area: &quot; + shape.getArea());
    }
}
</code></pre>
<h3>TypeScript Example</h3>
<p><strong>Violating LSP:</strong></p>
<pre><code class="language-typescript">class Vehicle {
    startEngine(): void {
        console.log(&quot;Engine started&quot;);
    }
    
    accelerate(): void {
        console.log(&quot;Accelerating...&quot;);
    }
}

class Car extends Vehicle {
    startEngine(): void {
        console.log(&quot;Car engine started&quot;);
    }
    
    accelerate(): void {
        console.log(&quot;Car accelerating...&quot;);
    }
}

class Bicycle extends Vehicle {
    startEngine(): void {
        throw new Error(&quot;Bicycles don&#39;t have engines!&quot;);
    }
    
    accelerate(): void {
        console.log(&quot;Pedaling faster...&quot;);
    }
}

// This violates LSP because Bicycle can&#39;t substitute Vehicle
function startVehicle(vehicle: Vehicle): void {
    vehicle.startEngine(); // This will throw for Bicycle!
}
</code></pre>
<p><strong>Refactored - Applying LSP:</strong></p>
<pre><code class="language-typescript">// Base interface for all vehicles
interface Vehicle {
    accelerate(): void;
}

// Interface for motorized vehicles
interface MotorizedVehicle extends Vehicle {
    startEngine(): void;
}

// Interface for human-powered vehicles
interface HumanPoweredVehicle extends Vehicle {
    pedal(): void;
}

// Concrete implementations that honor their contracts
class Car implements MotorizedVehicle {
    startEngine(): void {
        console.log(&quot;Car engine started&quot;);
    }
    
    accelerate(): void {
        console.log(&quot;Car accelerating...&quot;);
    }
}

class Bicycle implements HumanPoweredVehicle {
    accelerate(): void {
        console.log(&quot;Pedaling faster...&quot;);
    }
    
    pedal(): void {
        console.log(&quot;Pedaling...&quot;);
    }
}

// Now substitution works correctly
function startMotorizedVehicle(vehicle: MotorizedVehicle): void {
    vehicle.startEngine(); // Safe - all motorized vehicles have engines
    vehicle.accelerate();
}

function rideHumanPoweredVehicle(vehicle: HumanPoweredVehicle): void {
    vehicle.pedal(); // Safe - all human-powered vehicles can pedal
    vehicle.accelerate();
}
</code></pre>
<h2>How This Principle Helps with Code Quality</h2>
<ol>
<li><strong>Predictable Behavior</strong>: Subclasses behave as expected when substituted</li>
<li><strong>Consistent Interfaces</strong>: Inheritance relationships maintain their contracts</li>
<li><strong>Reduced Bugs</strong>: Eliminates unexpected behavior from subclass substitution</li>
<li><strong>Better Design</strong>: Forces proper inheritance hierarchies</li>
<li><strong>Maintainable Code</strong>: Changes to subclasses don&#39;t break existing functionality</li>
</ol>
<h2>How This Principle Helps with Automated Testing</h2>
<ol>
<li><strong>Test Reusability</strong>: Tests for base classes can be reused for subclasses</li>
<li><strong>Consistent Testing</strong>: All subclasses can be tested using the same test patterns</li>
<li><strong>Mock Substitution</strong>: Subclasses can be used as mocks for base classes</li>
<li><strong>Regression Prevention</strong>: Substitution violations are caught during testing</li>
<li><strong>Comprehensive Coverage</strong>: Tests ensure all subclasses honor their contracts</li>
</ol>
<pre><code class="language-csharp">// Example of testing with LSP
[Test]
public void Eagle_CanSubstituteForFlyingBird()
{
    // Arrange
    IFlyingBird bird = new Eagle();
    
    // Act &amp; Assert
    Assert.DoesNotThrow(() =&gt; bird.Eat());
    Assert.DoesNotThrow(() =&gt; bird.Fly());
}

[Test]
public void Penguin_CanSubstituteForSwimmingBird()
{
    // Arrange
    ISwimmingBird bird = new Penguin();
    
    // Act &amp; Assert
    Assert.DoesNotThrow(() =&gt; bird.Eat());
    Assert.DoesNotThrow(() =&gt; bird.Swim());
}

[Test]
public void BirdWatcher_WatchFlyingBird_WorksWithAnyFlyingBird()
{
    // Arrange
    var watcher = new BirdWatcher();
    IFlyingBird eagle = new Eagle();
    
    // Act &amp; Assert
    Assert.DoesNotThrow(() =&gt; watcher.WatchFlyingBird(eagle));
}

// Test that demonstrates LSP compliance
[Test]
public void AllFlyingBirds_CanBeSubstituted()
{
    // Arrange
    var flyingBirds = new IFlyingBird[] { new Eagle() };
    
    // Act &amp; Assert
    foreach (var bird in flyingBirds)
    {
        Assert.DoesNotThrow(() =&gt; bird.Eat());
        Assert.DoesNotThrow(() =&gt; bird.Fly());
    }
}
</code></pre>
<h2>Summary</h2>
<p>The Liskov Substitution Principle is crucial for maintaining the integrity of object-oriented design. By ensuring that subclasses can be substituted for their base classes without breaking functionality, we achieve:</p>
<ul>
<li><strong>Reliability</strong>: Predictable behavior across inheritance hierarchies</li>
<li><strong>Consistency</strong>: Proper inheritance relationships that maintain contracts</li>
<li><strong>Maintainability</strong>: Changes to subclasses don&#39;t break existing code</li>
<li><strong>Testability</strong>: Subclasses can be tested using the same patterns as base classes</li>
</ul>
<p>This principle builds upon the Open/Closed Principle by ensuring that the extensions we create (subclasses) can be safely substituted for their base classes. It also sets the foundation for the Interface Segregation Principle, as proper substitution requires well-defined, focused interfaces.</p>
<h2>Exercise 1: Design - Liskov Substitution Principle</h2>
<h3>Objective</h3>
<p>Design inheritance hierarchies where subclasses can be substituted for their base classes without breaking functionality, following the Liskov Substitution Principle.</p>
<h3>Task</h3>
<p>Analyze the e-commerce system and design proper inheritance relationships that honor LSP.</p>
<ol>
<li><strong>Identify Inheritance Opportunities</strong>: Examine the refactored code from previous exercises and identify where inheritance relationships make sense</li>
<li><strong>Design Base Classes</strong>: Create abstract base classes or interfaces that define clear contracts</li>
<li><strong>Plan Subclasses</strong>: Design concrete implementations that honor the base class contracts</li>
<li><strong>Validate Substitution</strong>: Ensure that subclasses can be substituted for base classes without breaking functionality</li>
</ol>
<h3>Deliverables</h3>
<ul>
<li>Inheritance hierarchy design showing base classes and subclasses</li>
<li>Contract definitions for base classes (preconditions, postconditions, invariants)</li>
<li>Substitution validation plan</li>
<li>Examples of proper and improper inheritance relationships</li>
</ul>
<h3>Getting Started</h3>
<ol>
<li>Navigate to the <code>ecom-exercises</code> folder</li>
<li>Choose your preferred language (C#, Java, Python, or TypeScript)</li>
<li>Review your refactored code from SRP and OCP exercises</li>
<li>Identify where inheritance would be beneficial</li>
<li>Create your design without modifying any code</li>
</ol>
<hr>
<h2>Exercise 2: Implementation - Liskov Substitution Principle</h2>
<h3>Objective</h3>
<p>Implement your design from Exercise 1, ensuring that all existing unit tests continue to pass and subclasses can be substituted for base classes.</p>
<h3>Task</h3>
<p>Implement the inheritance hierarchies according to your design while maintaining system functionality.</p>
<ol>
<li><strong>Create Base Classes</strong>: Implement the abstract base classes or interfaces from your design</li>
<li><strong>Implement Subclasses</strong>: Create concrete implementations that honor the base class contracts</li>
<li><strong>Ensure Substitution</strong>: Verify that subclasses can be substituted for base classes without breaking functionality</li>
<li><strong>Maintain Functionality</strong>: Ensure all existing unit tests pass</li>
<li><strong>Test Polymorphism</strong>: Verify that polymorphic behavior works correctly with all implementations</li>
</ol>
<h3>Success Criteria</h3>
<ul>
<li>All existing unit tests pass</li>
<li>The application runs without errors</li>
<li>Subclasses can be substituted for base classes without breaking functionality</li>
<li>Polymorphic behavior works correctly</li>
<li>The system maintains the same external behavior</li>
</ul>
<h3>Getting Started</h3>
<ol>
<li>Use your design from Exercise 1 as a guide</li>
<li>Start by implementing the base classes</li>
<li>Create concrete implementations that honor the contracts</li>
<li>Run tests frequently to ensure you don&#39;t break existing functionality</li>
<li>Test substitution by using subclasses where base classes are expected</li>
</ol>
<h3>Implementation Best Practices</h3>
<h4>Git Workflow</h4>
<ol>
<li><p><strong>Create a Feature Branch</strong>: Start from main and create a new branch for your LSP refactoring</p>
<pre><code class="language-bash">git checkout main
git pull origin main
git checkout -b feature/lsp-refactoring
</code></pre>
</li>
<li><p><strong>Commit Frequently</strong>: Make small, focused commits as you refactor</p>
<pre><code class="language-bash">git add .
git commit -m &quot;Create PaymentProcessor base class&quot;
git commit -m &quot;Implement CreditCardProcessor&quot;
git commit -m &quot;Implement PayPalProcessor&quot;
git commit -m &quot;Add substitution tests for PaymentProcessor&quot;
git commit -m &quot;Create ShippingCalculator hierarchy&quot;
</code></pre>
</li>
<li><p><strong>Test After Each Change</strong>: Run tests after each refactoring step</p>
<pre><code class="language-bash"># Run tests to ensure nothing is broken
dotnet test  # or equivalent for your language
</code></pre>
</li>
</ol>
<h4>Industry Best Practices</h4>
<ol>
<li><strong>Contract Definition</strong>: Clearly define preconditions, postconditions, and invariants for base classes</li>
<li><strong>Substitution Testing</strong>: Create tests that verify subclasses can substitute for base classes</li>
<li><strong>Behavioral Compatibility</strong>: Ensure subclasses maintain the same behavior as base classes</li>
<li><strong>Exception Handling</strong>: Subclasses should not throw exceptions that base classes don&#39;t throw</li>
<li><strong>Return Type Covariance</strong>: Use covariant return types where appropriate</li>
<li><strong>Composition Over Inheritance</strong>: Consider composition when inheritance violates LSP</li>
<li><strong>Documentation</strong>: Document the behavioral contracts that subclasses must honor</li>
<li><strong>Refactoring Safety</strong>: Use polymorphism safely without breaking existing functionality</li>
</ol>
<h3>Learning Objectives</h3>
<p>After completing both exercises, you should be able to:</p>
<ul>
<li>Design inheritance hierarchies that honor LSP</li>
<li>Ensure subclasses can substitute for base classes</li>
<li>Implement LSP while maintaining system functionality</li>
<li>Identify and fix LSP violations</li>
<li>Use composition when inheritance is problematic</li>
</ul>
<p><strong>Next</strong>: The <a href="../4-Interface-segregation-principle/README.md">Interface Segregation Principle</a> builds upon LSP by ensuring that clients only depend on the interfaces they actually use, creating more focused and maintainable designs.</p>
</div></div></div></main></div><script src="/_next/static/chunks/webpack-07dfb49dd72788a4.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/6b40bd379144f5c8.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[3728,[],\"\"]\n5:I[9928,[],\"\"]\n6:I[6954,[],\"\"]\n7:I[7264,[],\"\"]\n9:I[8326,[\"326\",\"static/chunks/326-c01c22be8dcac7b1.js\",\"687\",\"static/chunks/app/docs/%5B...slug%5D/page-f5028c860b0f5f1d.js\"],\"\"]\na:T66be,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eLiskov Substitution Principle (LSP)\u003c/h1\u003e\n\u003ch2\u003eName\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eLiskov Substitution Principle\u003c/strong\u003e - The \u0026quot;L\u0026quot; in SOLID\u003c/p\u003e\n\u003ch2\u003eGoal of the Principle\u003c/h2\u003e\n\u003cp\u003eObjects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. Derived classes must be substitutable for their base classes, maintaining the same behavior and contracts.\u003c/p\u003e\n\u003ch2\u003eTheoretical Foundation\u003c/h2\u003e\n\u003ch3\u003eBarbara Liskov\u0026#39;s Original Work\u003c/h3\u003e\n\u003cp\u003eThe Liskov Substitution Principle was formally defined by Barbara Liskov in 1987 as part of her work on abstract data types and behavioral subtyping. Liskov\u0026#39;s work established the mathematical foundation for understanding when one type can safely substitute for another.\u003c/p\u003e\n\u003ch3\u003eBehavioral Subtyping Theory\u003c/h3\u003e\n\u003cp\u003eLSP formalizes the concept of behavioral subtyping, which states that a subtype should be substitutable for its supertype in all contexts. This is more restrictive than structural subtyping, which only requires matching method signatures.\u003c/p\u003e\n\u003ch3\u003eDesign by Contract\u003c/h3\u003e\n\u003cp\u003eThe principle is closely related to Bertrand Meyer\u0026#39;s Design by Contract methodology:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePreconditions\u003c/strong\u003e: Conditions that must be true before a method is called\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePostconditions\u003c/strong\u003e: Conditions that must be true after a method completes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInvariants\u003c/strong\u003e: Conditions that must always be true for an object\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eType Theory and Polymorphism\u003c/h3\u003e\n\u003cp\u003eLSP ensures that polymorphism works correctly by guaranteeing that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMethod calls on derived objects produce expected results\u003c/li\u003e\n\u003cli\u003eDerived objects maintain the same invariants as base objects\u003c/li\u003e\n\u003cli\u003eException handling remains consistent across the inheritance hierarchy\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eMathematical Foundation\u003c/h3\u003e\n\u003cp\u003eThe principle is based on the mathematical concept of substitutability, where if S is a subtype of T, then objects of type S can replace objects of type T without changing the correctness of the program.\u003c/p\u003e\n\u003ch2\u003eConsequences of Violating LSP\u003c/h2\u003e\n\u003ch3\u003eUnique LSP-Specific Issues\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003ePolymorphism Breakdown\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCode using base class references may fail with derived class objects\u003c/li\u003e\n\u003cli\u003eGeneric algorithms may produce incorrect results\u003c/li\u003e\n\u003cli\u003eCollection operations may behave unexpectedly\u003c/li\u003e\n\u003cli\u003eFramework code may malfunction\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eContract Violations\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMethods may throw unexpected exceptions\u003c/li\u003e\n\u003cli\u003eReturn values may not match expected types\u003c/li\u003e\n\u003cli\u003eSide effects may differ from base class behavior\u003c/li\u003e\n\u003cli\u003eProgram correctness cannot be guaranteed\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eTesting Inconsistencies\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTests that pass with base classes may fail with derived classes\u003c/li\u003e\n\u003cli\u003eMock objects may not behave like real objects\u003c/li\u003e\n\u003cli\u003eIntegration tests become unreliable\u003c/li\u003e\n\u003cli\u003eTest coverage becomes meaningless\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eInheritance Hierarchy Problems\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChanges to derived classes can break existing code\u003c/li\u003e\n\u003cli\u003eInheritance hierarchies become unreliable\u003c/li\u003e\n\u003cli\u003eCode reuse becomes dangerous\u003c/li\u003e\n\u003cli\u003eRefactoring becomes risky\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eImpact on Static Code Analysis\u003c/h2\u003e\n\u003ch3\u003eLSP-Specific Metrics\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003ePolymorphism Reliability\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConsistent behavior across inheritance hierarchies improves reliability scores\u003c/li\u003e\n\u003cli\u003ePredictable polymorphism reduces complexity in static analysis\u003c/li\u003e\n\u003cli\u003eBetter inheritance design metrics in tools like SonarQube\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eContract Compliance Detection\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTools can detect violations of method contracts\u003c/li\u003e\n\u003cli\u003eIdentification of precondition/postcondition violations\u003c/li\u003e\n\u003cli\u003eDetection of invariant breaking in subclasses\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eLSP-Specific Tool Benefits\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eESLint/TSLint (JavaScript/TypeScript)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBetter \u0026quot;no-dupe-class-members\u0026quot; compliance\u003c/li\u003e\n\u003cli\u003eImproved \u0026quot;no-useless-constructor\u0026quot; usage\u003c/li\u003e\n\u003cli\u003eReduced \u0026quot;prefer-const\u0026quot; violations in inheritance\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCheckstyle (Java)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBetter \u0026quot;VisibilityModifier\u0026quot; compliance\u003c/li\u003e\n\u003cli\u003eImproved \u0026quot;MethodLength\u0026quot; in inheritance hierarchies\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eFxCop/StyleCop (.NET)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFewer \u0026quot;CA1501\u0026quot; (Avoid excessive inheritance) violations\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eLSP-Specific Detection\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eLSP Violation Detection\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDetection of subclasses that don\u0026#39;t honor base class contracts\u003c/li\u003e\n\u003cli\u003eIdentification of methods that throw unexpected exceptions\u003c/li\u003e\n\u003cli\u003eRecognition of return type violations in inheritance\u003c/li\u003e\n\u003cli\u003eDetection of invariant breaking in subclasses\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eInheritance Analysis\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAnalysis of inheritance hierarchy depth and breadth\u003c/li\u003e\n\u003cli\u003eDetection of proper abstract class usage\u003c/li\u003e\n\u003cli\u003eRecognition of interface implementation compliance\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eRole in Improving Software Quality\u003c/h2\u003e\n\u003cp\u003eThe Liskov Substitution Principle is essential for maintaining the integrity of object-oriented design. It ensures that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eReliability\u003c/strong\u003e: Subclasses behave predictably when substituted for base classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConsistency\u003c/strong\u003e: Inheritance relationships maintain their intended behavior\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMaintainability\u003c/strong\u003e: Changes to subclasses don\u0026#39;t break existing code\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTestability\u003c/strong\u003e: Subclasses can be tested using the same test cases as base classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePolymorphism\u003c/strong\u003e: Runtime polymorphism works correctly and safely\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to Apply This Principle\u003c/h2\u003e\n\u003ch3\u003e1. Maintain Contracts\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eWhat it means\u003c/strong\u003e: Subclasses must honor the contracts established by their base classes. This includes method signatures, return types, exception handling, and behavioral expectations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow to do it\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEnsure subclasses implement all methods from the base class with compatible signatures\u003c/li\u003e\n\u003cli\u003eMaintain the same return types or use covariant return types where appropriate\u003c/li\u003e\n\u003cli\u003eDon\u0026#39;t change method parameters in ways that would break existing callers\u003c/li\u003e\n\u003cli\u003ePreserve the semantic meaning of method names and their intended behavior\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eExample from our code samples\u003c/strong\u003e: In the violating \u003ccode\u003eBird\u003c/code\u003e example, the \u003ccode\u003ePenguin\u003c/code\u003e class throws an exception when \u003ccode\u003eFly()\u003c/code\u003e is called, breaking the contract that all birds can fly. The refactored solution creates separate interfaces (\u003ccode\u003eIFlyingBird\u003c/code\u003e and \u003ccode\u003eISwimmingBird\u003c/code\u003e) so that each subclass only implements contracts it can actually honor.\u003c/p\u003e\n\u003ch3\u003e2. Preserve Invariants\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eWhat it means\u003c/strong\u003e: Subclasses must maintain the same invariants (conditions that are always true) as their base classes. These are the fundamental properties that define the object\u0026#39;s state and behavior.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow to do it\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIdentify the invariants that the base class maintains\u003c/li\u003e\n\u003cli\u003eEnsure subclasses don\u0026#39;t violate these invariants in their implementations\u003c/li\u003e\n\u003cli\u003eDocument invariants clearly so subclasses understand what they must preserve\u003c/li\u003e\n\u003cli\u003eTest invariants to ensure they hold for all subclasses\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eExample from our code samples\u003c/strong\u003e: In the violating \u003ccode\u003eRectangle\u003c/code\u003e/\u003ccode\u003eSquare\u003c/code\u003e example, the \u003ccode\u003eSquare\u003c/code\u003e class changes the behavior of \u003ccode\u003esetWidth()\u003c/code\u003e and \u003ccode\u003esetHeight()\u003c/code\u003e methods, violating the invariant that these methods should only affect their respective dimensions. The refactored solution makes \u003ccode\u003eSquare\u003c/code\u003e a separate class with its own \u003ccode\u003esetSide()\u003c/code\u003e method, preserving the invariants of both shapes.\u003c/p\u003e\n\u003ch3\u003e3. Avoid Weakening Preconditions\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eWhat it means\u003c/strong\u003e: Subclasses should not impose stricter requirements on their methods than the base class does. This would make the subclass less substitutable, not more.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow to do it\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDon\u0026#39;t add additional validation or requirements in subclass methods\u003c/li\u003e\n\u003cli\u003eDon\u0026#39;t require additional parameters or more specific types\u003c/li\u003e\n\u003cli\u003eDon\u0026#39;t impose stricter business rules than the base class\u003c/li\u003e\n\u003cli\u003eIf you need stricter validation, consider composition instead of inheritance\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eExample from our code samples\u003c/strong\u003e: If a base class \u003ccode\u003ePaymentProcessor\u003c/code\u003e accepts any amount greater than zero, a subclass shouldn\u0026#39;t require amounts to be above $10. This would make the subclass unusable in contexts where the base class is expected to handle smaller amounts.\u003c/p\u003e\n\u003ch3\u003e4. Avoid Strengthening Postconditions\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eWhat it means\u003c/strong\u003e: Subclasses should not weaken the guarantees made by base class methods. This would break the expectations of code that depends on the base class behavior.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow to do it\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDon\u0026#39;t reduce the functionality or capabilities promised by base class methods\u003c/li\u003e\n\u003cli\u003eDon\u0026#39;t change return values in ways that would break existing code\u003c/li\u003e\n\u003cli\u003eDon\u0026#39;t remove side effects that calling code might depend on\u003c/li\u003e\n\u003cli\u003eIf you need different behavior, consider composition or a different inheritance hierarchy\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eExample from our code samples\u003c/strong\u003e: If a base class \u003ccode\u003eLogger\u003c/code\u003e guarantees that all messages will be written to a file, a subclass shouldn\u0026#39;t only log messages above a certain priority level. This would break the contract and make the subclass unsuitable for contexts requiring all messages to be logged.\u003c/p\u003e\n\u003ch3\u003e5. Use Composition Over Inheritance\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eWhat it means\u003c/strong\u003e: When substitution becomes problematic or creates awkward inheritance relationships, consider using composition instead. This often leads to more flexible and maintainable designs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow to do it\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIdentify when inheritance relationships don\u0026#39;t naturally fit the \u0026quot;is-a\u0026quot; relationship\u003c/li\u003e\n\u003cli\u003eUse composition to combine behaviors from multiple sources\u003c/li\u003e\n\u003cli\u003eCreate interfaces that define the capabilities you need\u003c/li\u003e\n\u003cli\u003eImplement these interfaces through composition rather than inheritance\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eExample from our code samples\u003c/strong\u003e: The refactored \u003ccode\u003eBird\u003c/code\u003e solution uses composition by creating separate interfaces for different capabilities (\u003ccode\u003eIFlyingBird\u003c/code\u003e, \u003ccode\u003eISwimmingBird\u003c/code\u003e). A \u003ccode\u003ePenguin\u003c/code\u003e implements \u003ccode\u003eISwimmingBird\u003c/code\u003e and can be used wherever swimming behavior is needed, without forcing it to implement flying behavior it doesn\u0026#39;t have.\u003c/p\u003e\n\u003ch2\u003eExamples of Violations and Refactoring\u003c/h2\u003e\n\u003ch3\u003eC# Example\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eViolating LSP:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Bird\n{\n    public virtual void Fly()\n    {\n        Console.WriteLine(\u0026quot;Flying...\u0026quot;);\n    }\n    \n    public virtual void Eat()\n    {\n        Console.WriteLine(\u0026quot;Eating...\u0026quot;);\n    }\n}\n\npublic class Eagle : Bird\n{\n    public override void Fly()\n    {\n        Console.WriteLine(\u0026quot;Eagle soaring high...\u0026quot;);\n    }\n}\n\npublic class Penguin : Bird\n{\n    public override void Fly()\n    {\n        throw new NotImplementedException(\u0026quot;Penguins can\u0026#39;t fly!\u0026quot;);\n    }\n}\n\n// This violates LSP because Penguin can\u0026#39;t substitute Bird\npublic class BirdWatcher\n{\n    public void WatchBird(Bird bird)\n    {\n        bird.Eat();\n        bird.Fly(); // This will throw exception for Penguin!\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eRefactored - Applying LSP:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// Base interface for all birds\npublic interface IBird\n{\n    void Eat();\n}\n\n// Interface for flying birds only\npublic interface IFlyingBird : IBird\n{\n    void Fly();\n}\n\n// Interface for swimming birds\npublic interface ISwimmingBird : IBird\n{\n    void Swim();\n}\n\n// Concrete implementations that honor their contracts\npublic class Eagle : IFlyingBird\n{\n    public void Eat()\n    {\n        Console.WriteLine(\u0026quot;Eagle eating...\u0026quot;);\n    }\n    \n    public void Fly()\n    {\n        Console.WriteLine(\u0026quot;Eagle soaring high...\u0026quot;);\n    }\n}\n\npublic class Penguin : ISwimmingBird\n{\n    public void Eat()\n    {\n        Console.WriteLine(\u0026quot;Penguin eating...\u0026quot;);\n    }\n    \n    public void Swim()\n    {\n        Console.WriteLine(\u0026quot;Penguin swimming...\u0026quot;);\n    }\n}\n\n// Now substitution works correctly\npublic class BirdWatcher\n{\n    public void WatchFlyingBird(IFlyingBird bird)\n    {\n        bird.Eat();\n        bird.Fly(); // Safe - all flying birds can fly\n    }\n    \n    public void WatchSwimmingBird(ISwimmingBird bird)\n    {\n        bird.Eat();\n        bird.Swim(); // Safe - all swimming birds can swim\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eJava Example\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eViolating LSP:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Rectangle {\n    protected int width;\n    protected int height;\n    \n    public void setWidth(int width) {\n        this.width = width;\n    }\n    \n    public void setHeight(int height) {\n        this.height = height;\n    }\n    \n    public int getArea() {\n        return width * height;\n    }\n}\n\npublic class Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width; // Violates LSP - changes behavior\n    }\n    \n    @Override\n    public void setHeight(int height) {\n        this.width = height; // Violates LSP - changes behavior\n        this.height = height;\n    }\n}\n\n// This violates LSP because Square changes Rectangle\u0026#39;s behavior\npublic class AreaCalculator {\n    public void calculateArea(Rectangle rectangle) {\n        rectangle.setWidth(5);\n        rectangle.setHeight(4);\n        // Expects 20, but gets 16 for Square!\n        System.out.println(\u0026quot;Area: \u0026quot; + rectangle.getArea());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eRefactored - Applying LSP:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Abstract base class that defines the contract\npublic abstract class Shape {\n    public abstract int getArea();\n}\n\n// Concrete implementations that honor their contracts\npublic class Rectangle extends Shape {\n    private int width;\n    private int height;\n    \n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    public void setWidth(int width) {\n        this.width = width;\n    }\n    \n    public void setHeight(int height) {\n        this.height = height;\n    }\n    \n    @Override\n    public int getArea() {\n        return width * height;\n    }\n}\n\npublic class Square extends Shape {\n    private int side;\n    \n    public Square(int side) {\n        this.side = side;\n    }\n    \n    public void setSide(int side) {\n        this.side = side;\n    }\n    \n    @Override\n    public int getArea() {\n        return side * side;\n    }\n}\n\n// Now substitution works correctly\npublic class AreaCalculator {\n    public void calculateArea(Shape shape) {\n        System.out.println(\u0026quot;Area: \u0026quot; + shape.getArea());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eTypeScript Example\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eViolating LSP:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eclass Vehicle {\n    startEngine(): void {\n        console.log(\u0026quot;Engine started\u0026quot;);\n    }\n    \n    accelerate(): void {\n        console.log(\u0026quot;Accelerating...\u0026quot;);\n    }\n}\n\nclass Car extends Vehicle {\n    startEngine(): void {\n        console.log(\u0026quot;Car engine started\u0026quot;);\n    }\n    \n    accelerate(): void {\n        console.log(\u0026quot;Car accelerating...\u0026quot;);\n    }\n}\n\nclass Bicycle extends Vehicle {\n    startEngine(): void {\n        throw new Error(\u0026quot;Bicycles don\u0026#39;t have engines!\u0026quot;);\n    }\n    \n    accelerate(): void {\n        console.log(\u0026quot;Pedaling faster...\u0026quot;);\n    }\n}\n\n// This violates LSP because Bicycle can\u0026#39;t substitute Vehicle\nfunction startVehicle(vehicle: Vehicle): void {\n    vehicle.startEngine(); // This will throw for Bicycle!\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eRefactored - Applying LSP:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// Base interface for all vehicles\ninterface Vehicle {\n    accelerate(): void;\n}\n\n// Interface for motorized vehicles\ninterface MotorizedVehicle extends Vehicle {\n    startEngine(): void;\n}\n\n// Interface for human-powered vehicles\ninterface HumanPoweredVehicle extends Vehicle {\n    pedal(): void;\n}\n\n// Concrete implementations that honor their contracts\nclass Car implements MotorizedVehicle {\n    startEngine(): void {\n        console.log(\u0026quot;Car engine started\u0026quot;);\n    }\n    \n    accelerate(): void {\n        console.log(\u0026quot;Car accelerating...\u0026quot;);\n    }\n}\n\nclass Bicycle implements HumanPoweredVehicle {\n    accelerate(): void {\n        console.log(\u0026quot;Pedaling faster...\u0026quot;);\n    }\n    \n    pedal(): void {\n        console.log(\u0026quot;Pedaling...\u0026quot;);\n    }\n}\n\n// Now substitution works correctly\nfunction startMotorizedVehicle(vehicle: MotorizedVehicle): void {\n    vehicle.startEngine(); // Safe - all motorized vehicles have engines\n    vehicle.accelerate();\n}\n\nfunction rideHumanPoweredVehicle(vehicle: HumanPoweredVehicle): void {\n    vehicle.pedal(); // Safe - all human-powered vehicles can pedal\n    vehicle.accelerate();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eHow This Principle Helps with Code Quality\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePredictable Behavior\u003c/strong\u003e: Subclasses behave as expected when substituted\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConsistent Interfaces\u003c/strong\u003e: Inheritance relationships maintain their contracts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReduced Bugs\u003c/strong\u003e: Eliminates unexpected behavior from subclass substitution\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBetter Design\u003c/strong\u003e: Forces proper inheritance hierarchies\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMaintainable Code\u003c/strong\u003e: Changes to subclasses don\u0026#39;t break existing functionality\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eHow This Principle Helps with Automated Testing\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eTest Reusability\u003c/strong\u003e: Tests for base classes can be reused for subclasses\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConsistent Testing\u003c/strong\u003e: All subclasses can be tested using the same test patterns\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMock Substitution\u003c/strong\u003e: Subclasses can be used as mocks for base classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRegression Prevention\u003c/strong\u003e: Substitution violations are caught during testing\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eComprehensive Coverage\u003c/strong\u003e: Tests ensure all subclasses honor their contracts\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// Example of testing with LSP\n[Test]\npublic void Eagle_CanSubstituteForFlyingBird()\n{\n    // Arrange\n    IFlyingBird bird = new Eagle();\n    \n    // Act \u0026amp; Assert\n    Assert.DoesNotThrow(() =\u0026gt; bird.Eat());\n    Assert.DoesNotThrow(() =\u0026gt; bird.Fly());\n}\n\n[Test]\npublic void Penguin_CanSubstituteForSwimmingBird()\n{\n    // Arrange\n    ISwimmingBird bird = new Penguin();\n    \n    // Act \u0026amp; Assert\n    Assert.DoesNotThrow(() =\u0026gt; bird.Eat());\n    Assert.DoesNotThrow(() =\u0026gt; bird.Swim());\n}\n\n[Test]\npublic void BirdWatcher_WatchFlyingBird_WorksWithAnyFlyingBird()\n{\n    // Arrange\n    var watcher = new BirdWatcher();\n    IFlyingBird eagle = new Eagle();\n    \n    // Act \u0026amp; Assert\n    Assert.DoesNotThrow(() =\u0026gt; watcher.WatchFlyingBird(eagle));\n}\n\n// Test that demonstrates LSP compliance\n[Test]\npublic void AllFlyingBirds_CanBeSubstituted()\n{\n    // Arrange\n    var flyingBirds = new IFlyingBird[] { new Eagle() };\n    \n    // Act \u0026amp; Assert\n    foreach (var bird in flyingBirds)\n    {\n        Assert.DoesNotThrow(() =\u0026gt; bird.Eat());\n        Assert.DoesNotThrow(() =\u0026gt; bird.Fly());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSummary\u003c/h2\u003e\n\u003cp\u003eThe Liskov Substitution Principle is crucial for maintaining the integrity of object-oriented design. By ensuring that subclasses can be substituted for their base classes without breaking functionality, we achieve:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eReliability\u003c/strong\u003e: Predictable behavior across inheritance hierarchies\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConsistency\u003c/strong\u003e: Proper inheritance relationships that maintain contracts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMaintainability\u003c/strong\u003e: Changes to subclasses don\u0026#39;t break existing code\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTestability\u003c/strong\u003e: Subclasses can be tested using the same patterns as base classes\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis principle builds upon the Open/Closed Principle by ensuring that the extensions we create (subclasses) can be safely substituted for their base classes. It also sets the foundation for the Interface Segregation Principle, as proper substitution requires well-defined, focused interfaces.\u003c/p\u003e\n\u003ch2\u003eExercise 1: Design - Liskov Substitution Principle\u003c/h2\u003e\n\u003ch3\u003eObjective\u003c/h3\u003e\n\u003cp\u003eDesign inheritance hierarchies where subclasses can be substituted for their base classes without breaking functionality, following the Liskov Substitution Principle.\u003c/p\u003e\n\u003ch3\u003eTask\u003c/h3\u003e\n\u003cp\u003eAnalyze the e-commerce system and design proper inheritance relationships that honor LSP.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eIdentify Inheritance Opportunities\u003c/strong\u003e: Examine the refactored code from previous exercises and identify where inheritance relationships make sense\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDesign Base Classes\u003c/strong\u003e: Create abstract base classes or interfaces that define clear contracts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePlan Subclasses\u003c/strong\u003e: Design concrete implementations that honor the base class contracts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eValidate Substitution\u003c/strong\u003e: Ensure that subclasses can be substituted for base classes without breaking functionality\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eDeliverables\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eInheritance hierarchy design showing base classes and subclasses\u003c/li\u003e\n\u003cli\u003eContract definitions for base classes (preconditions, postconditions, invariants)\u003c/li\u003e\n\u003cli\u003eSubstitution validation plan\u003c/li\u003e\n\u003cli\u003eExamples of proper and improper inheritance relationships\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eGetting Started\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eNavigate to the \u003ccode\u003eecom-exercises\u003c/code\u003e folder\u003c/li\u003e\n\u003cli\u003eChoose your preferred language (C#, Java, Python, or TypeScript)\u003c/li\u003e\n\u003cli\u003eReview your refactored code from SRP and OCP exercises\u003c/li\u003e\n\u003cli\u003eIdentify where inheritance would be beneficial\u003c/li\u003e\n\u003cli\u003eCreate your design without modifying any code\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2\u003eExercise 2: Implementation - Liskov Substitution Principle\u003c/h2\u003e\n\u003ch3\u003eObjective\u003c/h3\u003e\n\u003cp\u003eImplement your design from Exercise 1, ensuring that all existing unit tests continue to pass and subclasses can be substituted for base classes.\u003c/p\u003e\n\u003ch3\u003eTask\u003c/h3\u003e\n\u003cp\u003eImplement the inheritance hierarchies according to your design while maintaining system functionality.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eCreate Base Classes\u003c/strong\u003e: Implement the abstract base classes or interfaces from your design\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eImplement Subclasses\u003c/strong\u003e: Create concrete implementations that honor the base class contracts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEnsure Substitution\u003c/strong\u003e: Verify that subclasses can be substituted for base classes without breaking functionality\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMaintain Functionality\u003c/strong\u003e: Ensure all existing unit tests pass\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTest Polymorphism\u003c/strong\u003e: Verify that polymorphic behavior works correctly with all implementations\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eSuccess Criteria\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAll existing unit tests pass\u003c/li\u003e\n\u003cli\u003eThe application runs without errors\u003c/li\u003e\n\u003cli\u003eSubclasses can be substituted for base classes without breaking functionality\u003c/li\u003e\n\u003cli\u003ePolymorphic behavior works correctly\u003c/li\u003e\n\u003cli\u003eThe system maintains the same external behavior\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eGetting Started\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eUse your design from Exercise 1 as a guide\u003c/li\u003e\n\u003cli\u003eStart by implementing the base classes\u003c/li\u003e\n\u003cli\u003eCreate concrete implementations that honor the contracts\u003c/li\u003e\n\u003cli\u003eRun tests frequently to ensure you don\u0026#39;t break existing functionality\u003c/li\u003e\n\u003cli\u003eTest substitution by using subclasses where base classes are expected\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eImplementation Best Practices\u003c/h3\u003e\n\u003ch4\u003eGit Workflow\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eCreate a Feature Branch\u003c/strong\u003e: Start from main and create a new branch for your LSP refactoring\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit checkout main\ngit pull origin main\ngit checkout -b feature/lsp-refactoring\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eCommit Frequently\u003c/strong\u003e: Make small, focused commits as you refactor\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit add .\ngit commit -m \u0026quot;Create PaymentProcessor base class\u0026quot;\ngit commit -m \u0026quot;Implement CreditCardProcessor\u0026quot;\ngit commit -m \u0026quot;Implement PayPalProcessor\u0026quot;\ngit commit -m \u0026quot;Add substitution tests for PaymentProcessor\u0026quot;\ngit commit -m \u0026quot;Create ShippingCalculator hierarchy\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eTest After Each Change\u003c/strong\u003e: Run tests after each refactoring step\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Run tests to ensure nothing is broken\ndotnet test  # or equivalent for your language\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003eIndustry Best Practices\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eContract Definition\u003c/strong\u003e: Clearly define preconditions, postconditions, and invariants for base classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSubstitution Testing\u003c/strong\u003e: Create tests that verify subclasses can substitute for base classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBehavioral Compatibility\u003c/strong\u003e: Ensure subclasses maintain the same behavior as base classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eException Handling\u003c/strong\u003e: Subclasses should not throw exceptions that base classes don\u0026#39;t throw\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReturn Type Covariance\u003c/strong\u003e: Use covariant return types where appropriate\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eComposition Over Inheritance\u003c/strong\u003e: Consider composition when inheritance violates LSP\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDocumentation\u003c/strong\u003e: Document the behavioral contracts that subclasses must honor\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRefactoring Safety\u003c/strong\u003e: Use polymorphism safely without breaking existing functionality\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eLearning Objectives\u003c/h3\u003e\n\u003cp\u003eAfter completing both exercises, you should be able to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDesign inheritance hierarchies that honor LSP\u003c/li\u003e\n\u003cli\u003eEnsure subclasses can substitute for base classes\u003c/li\u003e\n\u003cli\u003eImplement LSP while maintaining system functionality\u003c/li\u003e\n\u003cli\u003eIdentify and fix LSP violations\u003c/li\u003e\n\u003cli\u003eUse composition when inheritance is problematic\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNext\u003c/strong\u003e: The \u003ca href=\"../4-Interface-segregation-principle/README.md\"\u003eInterface Segregation Principle\u003c/a\u003e builds upon LSP by ensuring that clients only depend on the interfaces they actually use, creating more focused and maintainable designs.\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/6b40bd379144f5c8.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"Mi_IUBpRsd6BRYXmSnup_\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/docs/1-SOLID-Principles/3-Liskov-substitution-principle/README\",\"initialTree\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"1-SOLID-Principles/3-Liskov-substitution-principle/README\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"1-SOLID-Principles\\\",\\\"3-Liskov-substitution-principle\\\",\\\"README\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L4\"],\"globalErrorComponent\":\"$5\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700\u0026display=swap\",\"rel\":\"stylesheet\"}]]}],[\"$\",\"body\",null,{\"className\":\"antialiased\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\",[\"slug\",\"1-SOLID-Principles/3-Liskov-substitution-principle/README\",\"c\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$L8\",[\"$\",\"div\",null,{\"className\":\"flex min-h-screen bg-gray-50\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"sidebar\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar-nav\",\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"text-lg font-semibold text-gray-900 mb-4 block hover:text-blue-600\",\"children\":\"‚Üê Engineering 101\"}],[\"$\",\"h2\",null,{\"className\":\"text-lg font-semibold text-gray-900 mb-4\",\"children\":\"Course Content\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles\",\"className\":\"sidebar-item\",\"children\":\"1-SOLID-Principles\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/0-README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/0-README\",\"className\":\"sidebar-item\",\"children\":\"0-README\"}],false]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/1-Single-class-reponsibility-principle\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/1-Single-class-reponsibility-principle\",\"className\":\"sidebar-item\",\"children\":\"1-Single-class-reponsibility-principle\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/1-Single-class-reponsibility-principle/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/1-Single-class-reponsibility-principle/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/2-Open-closed-principle\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/2-Open-closed-principle\",\"className\":\"sidebar-item\",\"children\":\"2-Open-closed-principle\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/2-Open-closed-principle/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/2-Open-closed-principle/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/3-Liskov-substitution-principle\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/3-Liskov-substitution-principle\",\"className\":\"sidebar-item\",\"children\":\"3-Liskov-substitution-principle\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/3-Liskov-substitution-principle/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/3-Liskov-substitution-principle/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/4-Interface-segregation-principle\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/4-Interface-segregation-principle\",\"className\":\"sidebar-item\",\"children\":\"4-Interface-segregation-principle\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/4-Interface-segregation-principle/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/4-Interface-segregation-principle/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/5-Dependency-segregation-principle\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/5-Dependency-segregation-principle\",\"className\":\"sidebar-item\",\"children\":\"5-Dependency-segregation-principle\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/5-Dependency-segregation-principle/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/5-Dependency-segregation-principle/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application\",\"className\":\"sidebar-item\",\"children\":\"reference-application\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/CI-README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/CI-README\",\"className\":\"sidebar-item\",\"children\":\"CI-README\"}],false]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Dotnet\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Dotnet\",\"className\":\"sidebar-item\",\"children\":\"Dotnet\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Dotnet/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Dotnet/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Java\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Java\",\"className\":\"sidebar-item\",\"children\":\"Java\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Java/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Java/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Python\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Python\",\"className\":\"sidebar-item\",\"children\":\"Python\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Python/.pytest_cache\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Python/.pytest_cache\",\"className\":\"sidebar-item\",\"children\":\".pytest_cache\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Python/.pytest_cache/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Python/.pytest_cache/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/Python/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/Python/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}],[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/TypeScript\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/TypeScript\",\"className\":\"sidebar-item\",\"children\":\"TypeScript\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/1-SOLID-Principles/reference-application/TypeScript/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/1-SOLID-Principles/reference-application/TypeScript/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}]]}]}]]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design\",\"className\":\"sidebar-item\",\"children\":\"2-Domain-Driven-Design\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/0-README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/0-README\",\"className\":\"sidebar-item\",\"children\":\"0-README\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/1-Bounded-Contexts\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/1-Bounded-Contexts\",\"className\":\"sidebar-item\",\"children\":\"1-Bounded-Contexts\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/1-Bounded-Contexts/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/1-Bounded-Contexts/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/1-introduction-to-the-domain\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/1-introduction-to-the-domain\",\"className\":\"sidebar-item\",\"children\":\"1-introduction-to-the-domain\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/2-Ubiquitous-Language\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/2-Ubiquitous-Language\",\"className\":\"sidebar-item\",\"children\":\"2-Ubiquitous-Language\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/2-Ubiquitous-Language/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/2-Ubiquitous-Language/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/3-Domain-Models\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/3-Domain-Models\",\"className\":\"sidebar-item\",\"children\":\"3-Domain-Models\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/3-Domain-Models/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/3-Domain-Models/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/4-Context-Mapping\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/4-Context-Mapping\",\"className\":\"sidebar-item\",\"children\":\"4-Context-Mapping\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/4-Context-Mapping/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/4-Context-Mapping/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/5-Strategic-Patterns\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/5-Strategic-Patterns\",\"className\":\"sidebar-item\",\"children\":\"5-Strategic-Patterns\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/5-Strategic-Patterns/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/5-Strategic-Patterns/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples\",\"className\":\"sidebar-item\",\"children\":\"code-samples\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp\",\"className\":\"sidebar-item\",\"children\":\"csharp\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/02-order-entity\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/02-order-entity\",\"className\":\"sidebar-item\",\"children\":\"02-order-entity\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/03-money-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/03-money-value-object\",\"className\":\"sidebar-item\",\"children\":\"03-money-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/04-email-address-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/04-email-address-value-object\",\"className\":\"sidebar-item\",\"children\":\"04-email-address-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/05-pricing-service\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/05-pricing-service\",\"className\":\"sidebar-item\",\"children\":\"05-pricing-service\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/06-customer-module\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/06-customer-module\",\"className\":\"sidebar-item\",\"children\":\"06-customer-module\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/07-order-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/07-order-tests\",\"className\":\"sidebar-item\",\"children\":\"07-order-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/08-money-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/08-money-tests\",\"className\":\"sidebar-item\",\"children\":\"08-money-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/09-pricing-service-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/09-pricing-service-tests\",\"className\":\"sidebar-item\",\"children\":\"09-pricing-service-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/11-testing-anti-patterns\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/11-testing-anti-patterns\",\"className\":\"sidebar-item\",\"children\":\"11-testing-anti-patterns\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/12-testing-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/12-testing-best-practices\",\"className\":\"sidebar-item\",\"children\":\"12-testing-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/13-domain-modeling-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/13-domain-modeling-best-practices\",\"className\":\"sidebar-item\",\"children\":\"13-domain-modeling-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/csharp/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/csharp/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/introduction-to-the-domain\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/introduction-to-the-domain\",\"className\":\"sidebar-item\",\"children\":\"introduction-to-the-domain\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java\",\"className\":\"sidebar-item\",\"children\":\"java\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/02-money-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/02-money-value-object\",\"className\":\"sidebar-item\",\"children\":\"02-money-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/03-inventory-service\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/03-inventory-service\",\"className\":\"sidebar-item\",\"children\":\"03-inventory-service\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/03-order-entity\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/03-order-entity\",\"className\":\"sidebar-item\",\"children\":\"03-order-entity\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/04-email-address-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/04-email-address-value-object\",\"className\":\"sidebar-item\",\"children\":\"04-email-address-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/04-order-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/04-order-tests\",\"className\":\"sidebar-item\",\"children\":\"04-order-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/05-pricing-service\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/05-pricing-service\",\"className\":\"sidebar-item\",\"children\":\"05-pricing-service\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/06-customer-module\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/06-customer-module\",\"className\":\"sidebar-item\",\"children\":\"06-customer-module\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/07-order-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/07-order-tests\",\"className\":\"sidebar-item\",\"children\":\"07-order-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/08-money-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/08-money-tests\",\"className\":\"sidebar-item\",\"children\":\"08-money-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/09-pricing-service-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/09-pricing-service-tests\",\"className\":\"sidebar-item\",\"children\":\"09-pricing-service-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/11-testing-anti-patterns\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/11-testing-anti-patterns\",\"className\":\"sidebar-item\",\"children\":\"11-testing-anti-patterns\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/12-testing-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/12-testing-best-practices\",\"className\":\"sidebar-item\",\"children\":\"12-testing-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/13-domain-modeling-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/13-domain-modeling-best-practices\",\"className\":\"sidebar-item\",\"children\":\"13-domain-modeling-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/java/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/java/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python\",\"className\":\"sidebar-item\",\"children\":\"python\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/02-money-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/02-money-value-object\",\"className\":\"sidebar-item\",\"children\":\"02-money-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/03-order-entity\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/03-order-entity\",\"className\":\"sidebar-item\",\"children\":\"03-order-entity\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/04-email-address-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/04-email-address-value-object\",\"className\":\"sidebar-item\",\"children\":\"04-email-address-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/05-pricing-service\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/05-pricing-service\",\"className\":\"sidebar-item\",\"children\":\"05-pricing-service\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/06-customer-module\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/06-customer-module\",\"className\":\"sidebar-item\",\"children\":\"06-customer-module\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/07-order-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/07-order-tests\",\"className\":\"sidebar-item\",\"children\":\"07-order-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/08-money-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/08-money-tests\",\"className\":\"sidebar-item\",\"children\":\"08-money-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/09-pricing-service-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/09-pricing-service-tests\",\"className\":\"sidebar-item\",\"children\":\"09-pricing-service-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/11-testing-anti-patterns\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/11-testing-anti-patterns\",\"className\":\"sidebar-item\",\"children\":\"11-testing-anti-patterns\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/12-testing-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/12-testing-best-practices\",\"className\":\"sidebar-item\",\"children\":\"12-testing-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/13-domain-modeling-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/13-domain-modeling-best-practices\",\"className\":\"sidebar-item\",\"children\":\"13-domain-modeling-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/python/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/python/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript\",\"className\":\"sidebar-item\",\"children\":\"typescript\"}],[\"$\",\"div\",null,{\"className\":\"ml-4 mt-1\",\"children\":[\"$\",\"ul\",null,{\"className\":\"space-y-1\",\"children\":[[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/02-money-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/02-money-value-object\",\"className\":\"sidebar-item\",\"children\":\"02-money-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/03-order-entity\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/03-order-entity\",\"className\":\"sidebar-item\",\"children\":\"03-order-entity\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/04-email-address-value-object\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/04-email-address-value-object\",\"className\":\"sidebar-item\",\"children\":\"04-email-address-value-object\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/05-pricing-service\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/05-pricing-service\",\"className\":\"sidebar-item\",\"children\":\"05-pricing-service\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/06-customer-module\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/06-customer-module\",\"className\":\"sidebar-item\",\"children\":\"06-customer-module\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/07-order-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/07-order-tests\",\"className\":\"sidebar-item\",\"children\":\"07-order-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/08-money-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/08-money-tests\",\"className\":\"sidebar-item\",\"children\":\"08-money-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/09-pricing-service-tests\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/09-pricing-service-tests\",\"className\":\"sidebar-item\",\"children\":\"09-pricing-service-tests\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/11-testing-anti-patterns\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/11-testing-anti-patterns\",\"className\":\"sidebar-item\",\"children\":\"11-testing-anti-patterns\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/12-testing-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/12-testing-best-practices\",\"className\":\"sidebar-item\",\"children\":\"12-testing-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/13-domain-modeling-best-practices\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/13-domain-modeling-best-practices\",\"className\":\"sidebar-item\",\"children\":\"13-domain-modeling-best-practices\"}],false]}],[\"$\",\"li\",\"/docs/2-Domain-Driven-Design/code-samples/typescript/README\",{\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/docs/2-Domain-Driven-Design/code-samples/typescript/README\",\"className\":\"sidebar-item\",\"children\":\"README\"}],false]}]]}]}]]}]]}]}]]}]]}]}]]}]]}]]}]}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"div\",null,{\"className\":\"content-wrapper\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page-header\",\"children\":[\"$\",\"h1\",null,{\"className\":\"page-title\",\"children\":\"README\"}]}],[\"$\",\"div\",null,{\"className\":\"prose prose-lg max-w-none\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$a\"}}]}]]}]}]]}],null],\"segment\":\"__PAGE__?{\\\"slug\\\":[\\\"1-SOLID-Principles\\\",\\\"3-Liskov-substitution-principle\\\",\\\"README\\\"]}\"},\"styles\":[]}],\"segment\":[\"slug\",\"1-SOLID-Principles/3-Liskov-substitution-principle/README\",\"c\"]},\"styles\":[]}],\"segment\":\"docs\"},\"styles\":[]}]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"4:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Engineering 101\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"SOLID + DDD training site\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script></body></html>